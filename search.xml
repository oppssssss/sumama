<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript 类型转换</title>
    <url>/2020/04/22/JavaScript-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="隐式-vs-显式类型转换"><a href="#隐式-vs-显式类型转换" class="headerlink" title="隐式 vs 显式类型转换"></a>隐式 vs 显式类型转换</h2><p>类型转换可以分为<strong>隐式</strong>类型转换和<strong>显式</strong>类型转换。</p>
<p>当开发人员通过编写适当的代码(如Number(value))用于在类型之间进行转换时，就称为显式类型强制转换(或强制类型转换)。</p>
<p>然而 JavaScript 是弱类型语言，在某些操作下，值可以在两种类型之间自动的转换，这叫做隐式类型转换。在对不同类型的值使用运算符时通常会发生隐式类型转换。比如 1 == null, 2 / “5”, null + new Date()。当值被 if 语句包裹时也有可能发生，比如 if(value) {} 会将 value 转换为 boolean类型。</p>
<p>严格相等运算符（===）不会触发类型隐式转换，所以它可以用来比较值和类型是否都相等。</p>
<p>隐式类型转换是一把双刃剑，使用它虽然可以写更少的代码但有时候会出现难以被发现的bug。</p>
<h2 id="三种类型转换"><a href="#三种类型转换" class="headerlink" title="三种类型转换"></a>三种类型转换</h2><p>我们需要知道的第一个规则是：<strong>在 JS 中只有 3 种类型的转换</strong></p>
<ul>
<li>to string</li>
<li>to boolean</li>
<li>to number</li>
</ul>
<p>第二，类型转换的逻辑在原始类型和对象类型上是不同的，但是他们都只会转换成上面 3 种类型之一。</p>
<p>我们首先分析一下原始类型转换。</p>
<h2 id="String-类型转换"><a href="#String-类型转换" class="headerlink" title="String 类型转换"></a>String 类型转换</h2><p>String() 方法可以用来显式将值转为字符串，隐式转换通常在有 <strong>+</strong> 运算符并且有一个操作数是 string 类型时被触发，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String(123) &#x2F;&#x2F; 显式类型转换</span><br><span class="line"></span><br><span class="line">123 + &#39;&#39; &#x2F;&#x2F; 隐式类型转换</span><br></pre></td></tr></table></figure>

<p>所有原始类型转 String 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String(123)  &#x2F;&#x2F; &#39;123&#39;</span><br><span class="line">String(-12.3)  &#x2F;&#x2F; &#39;-12.3&#39;</span><br><span class="line">String(null)  &#x2F;&#x2F; &#39;null&#39;</span><br><span class="line">String(undefined)  &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line">String(true)  &#x2F;&#x2F; &#39;true&#39;</span><br></pre></td></tr></table></figure>

<p>Symbol 类型转 String 类型是比较严格的，它只能被显式的转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String(Symbol(&#39;symbol&#39;))  &#x2F;&#x2F; &#39;Symbol(symbol)&#39;</span><br><span class="line"></span><br><span class="line">&#39;&#39; + Symbol(&#39;symbol&#39;)  &#x2F;&#x2F; TypeError is thrown</span><br></pre></td></tr></table></figure>

<h2 id="Boolean-类型转换"><a href="#Boolean-类型转换" class="headerlink" title="Boolean 类型转换"></a>Boolean 类型转换</h2><p>Boolean() 方法可以用来显式将值转换成 boolean 型。</p>
<p>隐式类型转换通常在逻辑判断或者有逻辑运算符时被触发（|| &amp;&amp; !）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean(2)    &#x2F;&#x2F; 显示类型转换</span><br><span class="line">if(2) &#123;&#125;      &#x2F;&#x2F; 逻辑判断触发隐式类型转换</span><br><span class="line">!!2           &#x2F;&#x2F; 逻辑运算符触发隐式类型转换</span><br><span class="line">2 || &#39;hello&#39;  &#x2F;&#x2F; 逻辑运算符触发隐式类型转换</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 逻辑运算符（比如 || 和 &amp;&amp;）是在内部做了 boolean 类型转换，但实际上返回的是原始操作数的值，即使他们都不是 boolean 类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回 number 类型 123，而不是 boolean 型 true</span><br><span class="line">&#x2F;&#x2F; &#39;hello&#39; 和 &#39;123&#39; 仍然在内部会转换成 boolean 型来计算表达式</span><br><span class="line">let x &#x3D; &#39;hello&#39; &amp;&amp; 123  &#x2F;&#x2F; x &#x3D;&#x3D;&#x3D; 123</span><br></pre></td></tr></table></figure>

<p>boolean 类型转换只会有 <strong>true</strong> 或者 <strong>false</strong> 两种结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean(&#39;&#39;)           &#x2F;&#x2F; false</span><br><span class="line">Boolean(0)            &#x2F;&#x2F; false  </span><br><span class="line">Boolean(-0)           &#x2F;&#x2F; false</span><br><span class="line">Boolean(NaN)          &#x2F;&#x2F; false</span><br><span class="line">Boolean(null)         &#x2F;&#x2F; false</span><br><span class="line">Boolean(undefined)     &#x2F;&#x2F; false</span><br><span class="line">Boolean(false)        &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>任何不在上面列表中的值都会转换为 true, 包括 object, function, Array, Date 等，Symbol 类型是真值，空对象和空数组也是真值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean(&#123;&#125;)             &#x2F;&#x2F; true</span><br><span class="line">Boolean([])             &#x2F;&#x2F; true</span><br><span class="line">Boolean(Symbol())       &#x2F;&#x2F; true</span><br><span class="line">!!Symbol()              &#x2F;&#x2F; true</span><br><span class="line">Boolean(function() &#123;&#125;)  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h2 id="Number-类型转换"><a href="#Number-类型转换" class="headerlink" title="Number 类型转换"></a>Number 类型转换</h2><p>和 Boolean()、String() 方法一样， Number() 方法可以用来显式将值转换成 number 类型。</p>
<p>number 的隐式类型转换是比较复杂的，因为它可以在下面多种情况下被触发。</p>
<ul>
<li>比较操作（&gt;, &lt;, &lt;=, &gt;=）</li>
<li>按位操作（| &amp; ^ ~）</li>
<li>算数操作（- + * / %）， <strong>注意</strong>，当 + 操作存在任意的操作数是 string 类型时，不会触发 number 类型的隐式转换</li>
<li>一 元 + 操作</li>
<li>非严格相等操作（== 或者 !== ），<strong>注意</strong>，== 操作两个操作数都是 string 类型时，不会发生 number 类型的隐式转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number(&#39;123&#39;)    &#x2F;&#x2F; 显示类型转换</span><br><span class="line">+ &#39;123&#39;          &#x2F;&#x2F;  隐式类型转换</span><br><span class="line">123 !&#x3D; &quot;456&quot;    &#x2F;&#x2F;  隐式类型转换</span><br><span class="line">4 &gt; &quot;5&quot;        &#x2F;&#x2F;  隐式类型转换</span><br><span class="line">5 &#x2F; null      &#x2F;&#x2F;  隐式类型转换</span><br><span class="line">true | 0      &#x2F;&#x2F;  隐式类型转换</span><br></pre></td></tr></table></figure>

<p>接下来看一下原始类型显示转换 number 类型会发生什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number(null)                   &#x2F;&#x2F; 0</span><br><span class="line">Number(undefined)              &#x2F;&#x2F; NaN</span><br><span class="line">Number(true)                   &#x2F;&#x2F; 1</span><br><span class="line">Number(false)                  &#x2F;&#x2F; 0</span><br><span class="line">Number(&quot; 12 &quot;)                 &#x2F;&#x2F; 12</span><br><span class="line">Number(&quot;-12.34&quot;)               &#x2F;&#x2F; -12.34</span><br><span class="line">Number(&quot;\n&quot;)                   &#x2F;&#x2F; 0</span><br><span class="line">Number(&quot; 12s &quot;)                &#x2F;&#x2F; NaN</span><br><span class="line">Number(123)                    &#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure>

<p>当将一个字符串转换为一个数字时，引擎首先删除前尾空格、\n、\t 字符，如果被修剪的字符串不成为一个有效的数字，则返回 NaN。如果字符串为空，则返回 0。</p>
<p>Number() 方法对于 null 和 undefined 的处理是不同的， null 会转换为 0, undefined 会转换为 NaN</p>
<p>不管是显式还是隐式转换都不能将 Symbol 类型转为 number 类型，当试图这样操作时，会抛出错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number(Symbol(&#39;my symbol&#39;))    &#x2F;&#x2F; TypeError is thrown</span><br><span class="line">+Symbol(&#39;123&#39;)                 &#x2F;&#x2F; TypeError is thrown</span><br></pre></td></tr></table></figure>

<p>这里有 2 个特殊的规则需要记住：</p>
<ol>
<li>当将 == 应用于 null 或 undefined 时，不会发生数值转换。null 只等于 null 或 undefined，不等于其他任何值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null &#x3D;&#x3D; 0               &#x2F;&#x2F; false, null is not converted to 0</span><br><span class="line">null &#x3D;&#x3D; null            &#x2F;&#x2F; true</span><br><span class="line">undefined &#x3D;&#x3D; undefined  &#x2F;&#x2F; true</span><br><span class="line">null &#x3D;&#x3D; undefined       &#x2F;&#x2F; true</span><br><span class="line">undefined &#x3D;&#x3D; 0          &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<ol>
<li>NaN 不等于任何值，包括它自己</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN  &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">if(value !&#x3D;&#x3D; value) &#123; console.log(&#39;the value is NaN&#39;) &#125;</span><br></pre></td></tr></table></figure>

<h2 id="object-类型转换"><a href="#object-类型转换" class="headerlink" title="object 类型转换"></a>object 类型转换</h2><p>到这里我们已经深入了解了原始类型的转换，接下来我们来看一下 object 类型的转换。</p>
<p>当涉及到对象的操作比如：[1] + [2,3]，引擎首先会尝试将 object 类型转为原始类型，然后在将原始类型转为最终需要的类型，而且仍然只有 3 种类型的转换：number, string, boolean</p>
<p>最简单的情况是 boolean 类型的转换，任何非原始类型总是会转换成 true,无论对象或数组是否为空。</p>
<p>对象通过内部 [[ToPrimitive]] 方法转换为原始类型，该方法负责数字和字符串转换。</p>
<p>[[ToPrimitive]] 方法接受两个参数一个输入值和一个需要转换的类型（Numer or String）</p>
<p>number 和 string的转换都使用了对象的两个方法： valueOf 和 toString。这两个方法都在 Object.prototype 上被声明，因此可用于任何派生类，比如 Date, Array等。</p>
<p>通常上 [[ToPrimitive]] 算法如下：</p>
<ol>
<li>�如果输入的值已经是原始类型，直接返回这个值。</li>
<li>输入的值调用 toString() 方法，如果结果是原始类型，则返回。</li>
<li>输入的值调用 valueOf() 方法，如果结果是原始类型，则返回。</li>
<li>如果上面 3 个步骤之后，转换后的值仍然不是原始类型，则抛出 TypeError 错误。</li>
</ol>
<p>number 类型的转换首先会调用 valueOf() 方法，如果不是�原始值�在调用 toString() 方法。 string 类型的转换则相反。</p>
<p>大多数 JS 内置对象类型的 valueOf() 返回这个对象本身，其�结果经常被忽略，因为它不是一个原始类型。所以大多数情况下当 object 需要转换成 number 或 string 类型时最终都调��用了 toString() 方法。</p>
<p>当运算符不同时，[[ToPrimitive]] 方法接受的转换类型参数也不相同。当存在 == 或者 + 运算符时一般会��先触发 number 类型的转换再触发 string 类型转换。</p>
<p>在 JS 中你可以通过重写对象的 toString 和 valueOf 方法来修改对象到�原始类型转换的逻辑。</p>
<h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h2><p>接下来我们按照之前的转换逻辑来解释一下每一道题,看一下是否和你的答案一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true + false  &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>‘+’ 运算符会��触发 number 类型转换对于 true 和 false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12 &#x2F; &#39;6&#39;  &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>算数运算符会把字符串 ‘6’ 转为 number 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;number&quot; + 15 + 3  &#x2F;&#x2F; &quot;number153&quot;</span><br></pre></td></tr></table></figure>

<p>‘+’ 运算符按从左到右的顺序的执行，所以优先执行 “number” + 15, 把 15 转为 string 类型，得到 “number15” 然后同理执行 “number15” + 3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 + 3 + &quot;number&quot;  &#x2F;&#x2F; &quot;18number&quot;</span><br></pre></td></tr></table></figure>

<p>15 + 3 先执行，�运算符两边都是 number 类型 ，不用转换，然后执行 18 + “number” 最终得到 “18number”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] &gt; null  &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; &#39;1&#39; &gt; 0</span><br><span class="line">&#x3D;&#x3D;&gt; 1 &gt; 0</span><br><span class="line">&#x3D;&#x3D;&gt; true</span><br></pre></td></tr></table></figure>

<p>比较运算符 &gt; 执行 number 类型隐式转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;foo&quot; + + &quot;bar&quot;  &#x2F;&#x2F; &quot;fooNaN&quot;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; &quot;foo&quot; + (+&quot;bar&quot;)</span><br><span class="line">&#x3D;&#x3D;&gt; &quot;foo&quot; + NaN</span><br><span class="line">&#x3D;&#x3D;&gt; &quot;fooNaN&quot;</span><br></pre></td></tr></table></figure>

<p>一元 + 运算符比二元 + 运算符具有更高的优先级。所以 + bar表达式先求值。一元加号执行字符串“bar” 的 number 类型转换。因为字符串不代表一个有效的数字，所以结果是NaN。在第二步中，计算表达式’foo’ + NaN。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;true&#39; &#x3D;&#x3D; true &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; NaN &#x3D;&#x3D; 1</span><br><span class="line">&#x3D;&#x3D;&gt; false</span><br><span class="line"></span><br><span class="line">&#39;false&#39; &#x3D;&#x3D; false &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; NaN &#x3D;&#x3D; 0</span><br><span class="line">&#x3D;&#x3D;&gt; false</span><br></pre></td></tr></table></figure>

<p>== 运算符执行 number 类型转换，’true’ 转换为 NaN， boolean 类型 true 转换为 1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null &#x3D;&#x3D; &#39;&#39;  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>null 不等于任何值除了 null 和 undefined</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!!&quot;false&quot; &#x3D;&#x3D; !!&quot;true&quot;  &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; true &#x3D;&#x3D; true</span><br><span class="line">&#x3D;&#x3D;&gt; true</span><br></pre></td></tr></table></figure>

<p>!! 运算符将字符串 ‘true’ 和 ‘false’ 转为 boolean 类型 true, 因为不是空字符串，然后两边都是 boolean 型不在执行隐式转换操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;x&#39;] &#x3D;&#x3D; &#39;x&#39;  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>== 运算符对数组类型执行 number 转换，先调用对象的 valueOf() 方法，结果是数组本身，不是原始类型值，所以执行对象的 toString() 方法，得到字符串 ‘x’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[] + null + 1  &#x2F;&#x2F; &#39;null1&#39;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; &#39;&#39; + null + 1</span><br><span class="line">&#x3D;&#x3D;&gt; &#39;null&#39; + 1</span><br><span class="line">&#x3D;&#x3D;&gt; &#39;null1&#39;</span><br></pre></td></tr></table></figure>

<p>‘+’ 运算符执行 number 类型转换，先调用对象的 valueOf() 方法，结果是数组本身，不是原始类型值，所以执行对象的 toString() 方法，得到字符串 ‘’， 接下来执行表达式 ‘’ + null + 1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 || &quot;0&quot; &amp;&amp; &#123;&#125;  &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; (0 || &#39;0&#39;) &amp;&amp; &#123;&#125;</span><br><span class="line">&#x3D;&#x3D;&gt; (false || true) &amp;&amp; true</span><br><span class="line">&#x3D;&#x3D;&gt; true &amp;&amp; true</span><br><span class="line">&#x3D;&#x3D;&gt; true</span><br></pre></td></tr></table></figure>

<p>逻辑运算符 || 和 &amp;&amp; 将值转为 boolean 型，但是会返回原始值（不是 boolean）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3] &#x3D;&#x3D; [1,2,3]  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>当运算符两边类型相同时，不会执行类型转换，两个数组的内存地址不一样，所以返回 false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#125; + [] + &#123;&#125; + [1]  &#x2F;&#x2F; &#39;0[object Object]1&#39;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; +[] + &#123;&#125; + [1]</span><br><span class="line">&#x3D;&#x3D;&gt; 0 + &#123;&#125; + [1]</span><br><span class="line">&#x3D;&#x3D;&gt; 0 + &#39;[object Object]&#39; + &#39;1&#39;</span><br><span class="line">&#x3D;&#x3D;&gt; &#39;0[object Object]1&#39;</span><br></pre></td></tr></table></figure>

<p>所有的操作数都不是原始类型，所以会按照从左到右的顺序执行 number 类型的隐式转换， object 和 array 类型的 valueOf() 方法返回它们本身，所以直接忽略，执行 toString() 方法。 这里的技巧是，第一个 {} 不被视为 object，而是块声明语句，因此它被忽略。计算从 +[] 表达式开始，该表达式通过toString()方法转换为空字符串，然后转换为0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! + [] + [] + ![] &#x2F;&#x2F; &#39;truefalse&#39;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; !(+[]) + [] + (![])</span><br><span class="line">&#x3D;&#x3D;&gt; !0 + [] + false</span><br><span class="line">&#x3D;&#x3D;&gt; true + [] + false</span><br><span class="line">&#x3D;&#x3D;&gt; true + &#39;&#39; + false</span><br><span class="line">&#x3D;&#x3D;&gt; &#39;truefalse&#39;</span><br></pre></td></tr></table></figure>

<p>一元运算符优先执行，+[] 转为 number 类型 0，![] 转为 boolean 型 false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Date(0) - 0  &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; 0 - 0</span><br><span class="line">&#x3D;&#x3D;&gt; 0</span><br></pre></td></tr></table></figure>

<p>‘-‘ 运算符执行 number 类型隐式转换对于 Date 型的值，Date.valueOf() 返回到毫秒的时间戳。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Date(0) + 0</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; &#39;Thu Jan 01 1970 02:00:00 GMT+0200 (EET)&#39; + 0</span><br><span class="line">&#x3D;&#x3D;&gt; &#39;Thu Jan 01 1970 02:00:00 GMT+0200 (EET)0&#39;</span><br></pre></td></tr></table></figure>

<p>‘+’ 运算符触发默认转换，因此使用 toString() 方法，而不是 valueOf()</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
